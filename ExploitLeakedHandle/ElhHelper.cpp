#include "ElhHelper.h"

HANDLE ElhHelper::openProcessID(USHORT& uPID, DWORD dwDesiredAccess) {
    HANDLE hProcess = OpenProcess(dwDesiredAccess, FALSE, uPID);
    return hProcess ? hProcess : INVALID_HANDLE_VALUE;
}

std::wstring ElhHelper::getProcessName(HANDLE& hProcess) {
    wchar_t imagePath[MAX_PATH] = { 0 };
    if (GetModuleFileNameExW(hProcess, NULL, imagePath, MAX_PATH)) {
        const wchar_t* lastSlash = wcsrchr(imagePath, '\\');
        return lastSlash ? lastSlash + 1 : imagePath;
    }
    return L"<UNKNOWN>";
}

std::wstring ElhHelper::getProcessName(USHORT& uPID) {
    std::wstring procName = L"<UNKNOWN>";
    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
    if (hSnap != INVALID_HANDLE_VALUE) {
        PROCESSENTRY32 entry = { sizeof(PROCESSENTRY32) };
        do {
            if (entry.th32ProcessID == uPID) {
                procName = (entry.szExeFile);
                break;
            }
        } while (Process32Next(hSnap, &entry));
        CloseHandle(hSnap);
    }
    return procName;
}

std::wstring ElhHelper::getProcessImageFileName(HANDLE hProcess) {
    TCHAR tBuffer[MAX_PATH];
    if (GetProcessImageFileNameW(hProcess, tBuffer, MAX_PATH) > 0) {
        return std::wstring(tBuffer);
    }
    return L"<UNKNOWN>";
}

std::wstring ElhHelper::getObjectName(HANDLE hObject, UCHAR objectTypeIndex) {
    std::wstring result;
    DWORD processId;
    DWORD threadId;
    HANDLE hProcess;

    if (objectTypeIndex == 0x7) {
        processId = GetProcessId(hObject);
        result = ElhHelper::getProcessImageFileName(hObject);
        result += L" (" + std::to_wstring(processId) + L")";
        return result;
    } else if (objectTypeIndex == 0x8) {
        threadId = GetThreadId(hObject);
        processId = GetProcessIdOfThread(hObject);
        hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, processId);
        if (hProcess != NULL) {
            result = ElhHelper::getProcessImageFileName(hProcess);
            CloseHandle(hProcess);
        } else {
            result = L"<ACCESS DENIED>";
        }
        result += L" (" + std::to_wstring(processId) + L") : " + std::to_wstring(threadId);
        return result;
    } else {
        NTSTATUS ntStatus;
        POBJECT_NAME_INFORMATION pObjectNameInfo = nullptr;
        ULONG ulObjectNameInfoLength = 0;
        while (ntStatus = NtQueryObject(hObject, ObjectNameInformation, pObjectNameInfo, ulObjectNameInfoLength, &ulObjectNameInfoLength) == STATUS_INFO_LENGTH_MISMATCH) {
            pObjectNameInfo = (POBJECT_NAME_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, ulObjectNameInfoLength);
        }
        if (NT_SUCCESS(ntStatus) && pObjectNameInfo != nullptr && pObjectNameInfo->Name.Length > 0) {
            return std::wstring(pObjectNameInfo->Name.Buffer, pObjectNameInfo->Name.Length / sizeof(wchar_t));
        }
    }

    return L"<UNKNOWN>";
}

DWORD ElhHelper::getProcessIntegrity(HANDLE& hProcess) {
    HANDLE hToken;
    DWORD dwIntegrityLevel = 0;
    DWORD dwLengthNeeded = 0;
    PTOKEN_MANDATORY_LABEL pTIL = nullptr;
    if (OpenProcessToken(hProcess, TOKEN_QUERY | TOKEN_QUERY_SOURCE, &hToken)) {
        if (GetTokenInformation(hToken, TokenIntegrityLevel, NULL, 0, &dwLengthNeeded) || GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
            pTIL = (PTOKEN_MANDATORY_LABEL)LocalAlloc(0, dwLengthNeeded);
            if (GetTokenInformation(hToken, TokenIntegrityLevel, pTIL, dwLengthNeeded, &dwLengthNeeded) && pTIL != nullptr) {
                dwIntegrityLevel = *GetSidSubAuthority(pTIL->Label.Sid, *GetSidSubAuthorityCount(pTIL->Label.Sid) - 1);
            }
        }
    }
    CloseHandle(hToken);
    return dwIntegrityLevel;
}

DWORD ElhHelper::getParentProcessID(HANDLE hProcess) {
    PROCESS_BASIC_INFORMATION pbi = {};
    NTSTATUS ntStatus = NtQueryInformationProcess(hProcess, ProcessBasicInformation, &pbi, sizeof(pbi), NULL);

    return NT_SUCCESS(ntStatus) ? (DWORD)pbi.InheritedFromUniqueProcessId : 0;
}

HANDLE ElhHelper::duplicateHandle(SYSTEM_HANDLE_TABLE_ENTRY_INFO& handleInfo, HANDLE& hProcess) {
    HANDLE dupedHandle = nullptr;
    DuplicateHandle(hProcess, (HANDLE)handleInfo.HandleValue, GetCurrentProcess(), &dupedHandle, 0, TRUE, DUPLICATE_SAME_ACCESS);
    return dupedHandle;
}

bool ElhHelper::accessContainsRights(DWORD dwGrantedAccess, DWORD dwAccessRights) {
    return (dwGrantedAccess & dwAccessRights) == dwAccessRights;
}

bool ElhHelper::getModuleInfo(HMODULE hModule, DWORD64& baseAddr, DWORD64& moduleSize) {
    MODULEINFO modInfo = { 0 };
    if (!GetModuleInformation(GetCurrentProcess(), hModule, &modInfo, sizeof(MODULEINFO))) {
        return false;
    }
    baseAddr = (DWORD64)modInfo.lpBaseOfDll;
    moduleSize = (DWORD64)modInfo.SizeOfImage;
    return true;
}

std::wstring ElhHelper::getELHDirectory() {
    wchar_t szModulePath[MAX_PATH] = { 0 };
    GetModuleFileNameW(NULL, szModulePath, MAX_PATH);
    PathRemoveFileSpecW(szModulePath);
    return std::wstring(szModulePath);
}

std::vector<BYTE> ElhHelper::decodeBase64(const std::string& base64String) {
    DWORD dwDataSize = 0;
    CryptStringToBinaryA(base64String.c_str(), 0, CRYPT_STRING_BASE64, NULL, &dwDataSize, NULL, NULL);

    std::vector<BYTE> decodedData(dwDataSize);
    CryptStringToBinaryA(base64String.c_str(), 0, CRYPT_STRING_BASE64, decodedData.data(), &dwDataSize, NULL, NULL);

    return decodedData;
}

bool ElhHelper::writeDataToFile(const std::wstring& filePath, const std::vector<BYTE>& data) {
    HANDLE hFile = CreateFileW(filePath.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE) {
        DWORD dwBytesWritten = 0;
        bool bSuccess = WriteFile(hFile, data.data(), data.size(), &dwBytesWritten, NULL) && (dwBytesWritten == data.size());
        CloseHandle(hFile);
        return bSuccess;
    }
    return false;
}

DWORD64 ElhHelper::findNullBytes(HMODULE hModule, int x) {
    DWORD64 runtimeImageBase;
    DWORD64 imageSize;
    if (!getModuleInfo(hModule, runtimeImageBase, imageSize)) {
        return 0;
    }

    MEMORY_BASIC_INFORMATION meminfo;
    for (DWORD64 offset = 0; offset < imageSize; ++offset) {
        bool found = true;
        DWORD64 address = runtimeImageBase + offset;

        VirtualQuery((LPCVOID)address, &meminfo, sizeof(MEMORY_BASIC_INFORMATION));
        if (!(meminfo.Protect & PAGE_READWRITE || meminfo.Protect & PAGE_WRITECOPY || meminfo.Protect & PAGE_EXECUTE_READWRITE || meminfo.Protect & PAGE_EXECUTE_WRITECOPY)) {
            continue;
        }

        for (int i = 0; i < x; ++i) {
            if (*((char*)(address + i)) != '\0') {
                found = false;
                break;
            }
        }

        if (found) {
            return address;
        }
    }

    return 0;
}