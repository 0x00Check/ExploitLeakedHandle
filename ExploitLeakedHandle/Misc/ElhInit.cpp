#include "ElhInit.h"
#include "ElhHelper.h"

void printBanner() {
	wprintf(
		L"\n  ______            _       _ _   _                _            _ _    _                 _ _"
		"\n |  ____|          | |     (_) | | |              | |          | | |  | |               | | |"
		"\n | |__  __  ___ __ | | ___  _| |_| |     ___  __ _| | _____  __| | |__| | __ _ _ __   __| | | ___"
		"\n |  __| \\ \\/ / '_ \\| |/ _ \\| | __| |    / _ \\/ _` | |/ / _ \\/ _` |  __  |/ _` | '_ \\ / _` | |/ _ \\"
		"\n | |____ >  <| |_) | | (_) | | |_| |___|  __/ (_| |   <  __/ (_| | |  | | (_| | | | | (_| | |  __/"
		"\n |______/_/\\_\\ .__/|_|\\___/|_|\\__|______\\___|\\__,_|_|\\_\\___|\\__,_|_|  |_|\\__,_|_| |_|\\__,_|_|\\___|"
		"\n             | |"
		"\n             |_|\n\n"
	);
}

PSYSTEM_HANDLE_INFORMATION getSystemHandleInformation() {
	NTSTATUS ntStatus;
	PSYSTEM_HANDLE_INFORMATION pSystemHandleInfo = nullptr;
	ULONG ulSystemHandleInfoLength = 0;
	while (ntStatus = NtQuerySystemInformation(SystemHandleInformation, pSystemHandleInfo, ulSystemHandleInfoLength, &ulSystemHandleInfoLength) == STATUS_INFO_LENGTH_MISMATCH) {
		pSystemHandleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, ulSystemHandleInfoLength);
	}
	if (!NT_SUCCESS(ntStatus)) {
		return nullptr;
	}
	return pSystemHandleInfo;
}

bool handleBelongsToELH(SYSTEM_HANDLE_TABLE_ENTRY_INFO& handleInfo) {
	return handleInfo.UniqueProcessId == GetCurrentProcessId();
}

bool handleIsInheritable(UCHAR& handleAttributes) {
	return handleAttributes & OBJ_INHERIT;
}

bool handleTypeIsInteresting(UCHAR& objectTypeIndex, LPCWSTR& handleType) {
	BOOL isInteresting = true;
	switch (objectTypeIndex) {
	case PROCESS_HANDLE_TYPE:
		handleType = L"PROCESS";
		break;
	case THREAD_HANDLE_TYPE:
		handleType = L"THREAD";
		break;
	case FILE_HANDLE_TYPE:
		handleType = L"FILE";
		break;
	case SECTION_HANDLE_TYPE:
		handleType = L"SECTION";
		break;
	case KEY_HANDLE_TYPE:
		handleType = L"KEY";
		break;
	default:
		isInteresting = false;
		break;
	}
	return isInteresting;
}

bool handleAccessIsInteresting(UCHAR& objectTypeIndex, ULONG& grantedAccess, std::vector<LPCWSTR>& accessRights) {
	BOOL hasInterestingRights = false;
	
	// Vector to store acess masks & their corresponding names for each type
	std::vector<std::pair<ULONG, LPCWSTR>> interestingAccessMasks;
	// Determine the relevant interesting access masks based on type
	switch (objectTypeIndex) {
	case PROCESS_HANDLE_TYPE:
		interestingAccessMasks = {
			{ PROCESS_ALL_ACCESS,     L"PROCESS_ALL_ACCESS" },
			{ PROCESS_CREATE_PROCESS, L"PROCESS_CREATE_PROCESS" },
			{ PROCESS_CREATE_THREAD,  L"PROCESS_CREATE_THREAD" },
			{ PROCESS_DUP_HANDLE,	  L"PROCESS_DUP_HANDLE" },
			{ PROCESS_VM_WRITE,	      L"PROCESS_VM_WRITE" }
		};
		break;
	case THREAD_HANDLE_TYPE:
		interestingAccessMasks = {
			{ THREAD_ALL_ACCESS,		   L"THREAD_ALL_ACCESS" },
			{ THREAD_DIRECT_IMPERSONATION, L"THREAD_DIRECT_IMPERSONATION" },
			{ THREAD_SET_CONTEXT,		   L"THREAD_SET_CONTEXT" }
		};
		break;
	case FILE_HANDLE_TYPE:
	case SECTION_HANDLE_TYPE:
	case KEY_HANDLE_TYPE:
		interestingAccessMasks = {
			{FILE_WRITE_DATA, L"FILE_WRITE_DATA"},
		};
		break;
	}

	for (auto accessMask : interestingAccessMasks) {
		if (accessContainsRights(grantedAccess, accessMask.first)) {
			hasInterestingRights = true;
			accessRights.push_back(accessMask.second);
		}
	}
	return hasInterestingRights;
}

void findLeakedHandles(PSYSTEM_HANDLE_INFORMATION& pSystemHandleInfo, std::vector<HANDLE_OBJ>& interestingHandles) {
	wprintf(L"[+] Checking %d handles for potential abuse..\n\n", pSystemHandleInfo->NumberOfHandles - 1);
	for (ULONG i = 0; i < pSystemHandleInfo->NumberOfHandles; i++) {
		SYSTEM_HANDLE_TABLE_ENTRY_INFO handleInfo = pSystemHandleInfo->Handles[i];

		// Skip if the handle belongs to the current process, isn't inheritable/potentially abusable, or lacks abusable access rights
		LPCWSTR handleType;
		std::vector<LPCWSTR> accessRights;
		if (
			handleBelongsToELH(handleInfo) || 
			!handleIsInheritable(handleInfo.HandleAttributes) ||
			!handleTypeIsInteresting(handleInfo.ObjectTypeIndex, handleType) ||
			!handleAccessIsInteresting(handleInfo.ObjectTypeIndex, handleInfo.GrantedAccess, accessRights)
		) {
			continue;
		}

		// Open handle to process -- if it fails, assume it's already priv and safe to skip
		HANDLE hProcess = openProcessID(handleInfo.UniqueProcessId, PROCESS_ALL_ACCESS);
		if (hProcess == INVALID_HANDLE_VALUE) {
			continue;
		}

		// Save proc name/integrity/parent ID before closing handle
		std::wstring processName = getProcessName(hProcess);
		DWORD dwProcIntegrity = getProcessIntegrity(hProcess);
		USHORT uPPID = getParentProcessID(hProcess);
		CloseHandle(hProcess);

		// Validate process integrity isn't already high
		if (dwProcIntegrity > SECURITY_MANDATORY_MEDIUM_RID || dwProcIntegrity <= SECURITY_MANDATORY_LOW_RID) {
			continue;
		}

		// Check if parent process integrity is higher (access denied/any fail == assume yes)
		HANDLE hParentProcess = openProcessID(uPPID, PROCESS_QUERY_LIMITED_INFORMATION);
		DWORD dwParentIntegrity;
		if (hParentProcess != INVALID_HANDLE_VALUE) {
			dwParentIntegrity = getProcessIntegrity(hParentProcess);
			CloseHandle(hParentProcess);
			if (dwParentIntegrity <= SECURITY_MANDATORY_MEDIUM_RID) {
				continue;
			}
		}

		// Get object name of handle
		HANDLE hProc = openProcessID(handleInfo.UniqueProcessId, PROCESS_ALL_ACCESS);
		HANDLE hLocal = duplicateHandle(handleInfo, hProc);
		std::wstring objectName = getObjectName(hLocal);

		// Save parent proc name
		std::wstring parentName = getProcessName(uPPID);

		// Create obj & store in vector
		HANDLE_OBJ ihData   = { 0 };
		ihData.handleInfo   = handleInfo;
		ihData.handleType   = handleType;
		ihData.handleRights = accessRights;
		ihData.objectName   = objectName;
		ihData.procName	    = processName;
		ihData.parentPID    = uPPID;
		ihData.parentName   = parentName;

		interestingHandles.push_back(ihData);
	}
}