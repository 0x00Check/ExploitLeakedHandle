#include "ElhHelper.h"

HANDLE openProcessID(USHORT& uPID, DWORD dwDesiredAccess) {
	HANDLE hProcess = OpenProcess(dwDesiredAccess, FALSE, uPID);
	if (!hProcess) {
		return INVALID_HANDLE_VALUE;
	}
	return hProcess;
}

std::wstring getProcessName(HANDLE& hProcess) {
	wchar_t imagePath[MAX_PATH] = { 0 };
	if (GetModuleFileNameExW(hProcess, NULL, imagePath, MAX_PATH)) {
		const wchar_t* lastSlash = wcsrchr(imagePath, '\\');
		return lastSlash ? lastSlash + 1 : imagePath;
	}
	return L"<UNKNOWN>";
}

std::wstring getProcessName(USHORT& uPID) {
	std::wstring procName = L"<UNKNOWN>";
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	if (hSnap != INVALID_HANDLE_VALUE) {
		PROCESSENTRY32 entry = { sizeof(PROCESSENTRY32) };
		do {
			if (entry.th32ProcessID == uPID) {
				procName = (entry.szExeFile);
				break;
			}
		} while (Process32Next(hSnap, &entry));
		CloseHandle(hSnap);
	}
	return procName;
}

std::wstring getObjectName(HANDLE handle) {
	NTSTATUS ntStatus;
	POBJECT_NAME_INFORMATION pObjectNameInfo = nullptr;
	ULONG ulObjectNameInfoLength = 0;
	while (ntStatus = NtQueryObject(handle, ObjectNameInformation, pObjectNameInfo, ulObjectNameInfoLength, &ulObjectNameInfoLength) == STATUS_INFO_LENGTH_MISMATCH) {
		pObjectNameInfo = (POBJECT_NAME_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, ulObjectNameInfoLength);
	}
	if (NT_SUCCESS(ntStatus) && pObjectNameInfo != nullptr && pObjectNameInfo->Name.Length > 0) {
		return std::wstring(pObjectNameInfo->Name.Buffer, pObjectNameInfo->Name.Length / sizeof(wchar_t));
	}
	return L"<UNKNOWN>";
}

DWORD getProcessIntegrity(HANDLE& hProcess) {
	HANDLE hToken;
	DWORD dwIntegrityLevel = 0;
	DWORD dwLengthNeeded = 0;
	PTOKEN_MANDATORY_LABEL pTIL = nullptr;
	if (OpenProcessToken(hProcess, TOKEN_QUERY | TOKEN_QUERY_SOURCE, &hToken)) {
		if (GetTokenInformation(hToken, TokenIntegrityLevel, NULL, 0, &dwLengthNeeded) || GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
			pTIL = (PTOKEN_MANDATORY_LABEL)LocalAlloc(0, dwLengthNeeded);
			if (GetTokenInformation(hToken, TokenIntegrityLevel, pTIL, dwLengthNeeded, &dwLengthNeeded) && pTIL != nullptr) {
				dwIntegrityLevel = *GetSidSubAuthority(pTIL->Label.Sid, *GetSidSubAuthorityCount(pTIL->Label.Sid) - 1);
			}
		}
	}
	CloseHandle(hToken);
	return dwIntegrityLevel;
}

DWORD getParentProcessID(HANDLE hProcess) {
	PROCESS_BASIC_INFORMATION pbi = {};
	DWORD dwParentPID = 0;
	NTSTATUS ntStatus = NtQueryInformationProcess(hProcess, ProcessBasicInformation, &pbi, sizeof(pbi), NULL);
	if (NT_SUCCESS(ntStatus)) {
		dwParentPID = (DWORD)pbi.InheritedFromUniqueProcessId;
	}
	return dwParentPID;
}

uintptr_t getModuleBaseAddress(const wchar_t* moduleName) {
	uintptr_t baseAddr = 0;
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, NULL);
	if (hSnap != INVALID_HANDLE_VALUE) {
		MODULEENTRY32 modEntry = { sizeof(MODULEENTRY32) };
		do {
			if (!_wcsicmp(modEntry.szModule, moduleName)) {
				baseAddr = (uintptr_t)modEntry.modBaseAddr;
				break;
			}
		} while (Module32Next(hSnap, &modEntry));
		CloseHandle(hSnap);
	}
	return baseAddr;
}

HANDLE duplicateHandle(SYSTEM_HANDLE_TABLE_ENTRY_INFO& handleInfo, HANDLE& hProcess) {
	HANDLE dupedHandle = nullptr;
	DuplicateHandle(hProcess, (HANDLE)handleInfo.HandleValue, GetCurrentProcess(), &dupedHandle, 0, TRUE, DUPLICATE_SAME_ACCESS);
	return dupedHandle;
}

bool accessContainsRights(DWORD dwGrantedAccess, DWORD dwAccessRights) {
	return (dwGrantedAccess & dwAccessRights) == dwAccessRights;
}
